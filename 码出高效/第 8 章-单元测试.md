# 第 8 章 单元测试

软件产品通常是由模块组合而成，模块又可以分成诸多子模块。最终的子模块是由不可再分的程序单元组成。对于这些程序单元的测试，即称为单元测试（Unit Testing，简称单元测试）。在面向对象编程中，通常认为最小单元就是方法。

单元测试的好处包括但不限于以下几点：

1. 提升软件质量
2. 促进代码优化
3. 增加重构自信
4. 提升研发效率

## 8.1 单元测试的基本原则

宏观上，单元测试要符合 AIR 原则；微观上，单元测试的代码层面要符合 BCDE 原则。

AIR 原则具体包括：

- A：Automatic（自动化）
- I：Independent（独立性）
- R：Repeatable（可重复）

单元测试应该是自动执行的。

为了保证单元测试稳定可靠便于维护，需要保证其独立性。用例之间不允许相互调用，也不允许出现执行次序的先后依赖。JUnit 的用例执行顺序是无序的，而 TestNG 支持测试用例的顺序执行（默认测试类内部各测试用例是按字典升序执行的，也可以通过 XML或 注解 priority 的方式来配置执行顺序）。

单元测试是可以重复执行的，不能受到外界环境的影响。

编写单元测试时要保证测试粒度要足够小。

编写单元测试用例时需要符合 BCDE 原则。

- B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。
- C：Correct，正确的输入，并得到预期结果。
- D：Design，与设计文档结合，来编写单元测试。
- E：Error，单元测试的目标时证明程序有错，而不是程序无措。

由于单元测试只是系统集成测试前的小模块测试，有些因素往往不具备，因此需要进行 Mock，例如：

（1）功能因素。比如单元测试方法内部调用功能不可用。

（2）时间因素。与时间相关的功能点。

（3）环境因素。政策环境，多端环境。

（4）数据因素。数据样本过小。

（5）其他因素。

最简单的 Mock 方式是硬编码，更优雅的方式是使用配置文件，最佳的方式是使用 Mock 框架，如 JMock、EasyMock、JMock等。



## 8.2 单元测试覆盖率

单元测试时以一种白盒测试，测试者依据程序的内部结构来实现测试代码。单元测试覆盖率是指业务代码被单元测试的比例和程度。

1. 粗粒度的覆盖。

   粗粒度的覆盖包括类覆盖和方法覆盖两种。类覆盖是指类中只要有方法或变量被测试用例调用或执行到，那么就说这个类被测试覆盖了。

   方法覆盖，只要在测试用例的执行过程中，某个方法被调用了，都认为该类被覆盖了。

2. 细粒度的覆盖。

   (1) 行覆盖。也称语句覆盖，用来量度可执行的语句是否被执行到。

   (2) 分支覆盖。也称判定覆盖，用来量度程序中每个判断分支是否都被执行到。

   (3) 条件判定覆盖。要求能够让每个条件的所有可能情况至少被执行一次，同时每个判定本身的所有可能结果也至少执行一次。

   (4) 条件组合覆盖。是指判定中所有条件的各种组合情况都至少出现一次。

   (5) 路径覆盖。要求能够测试到程序中所有可能路径。

## 8.3 单元测试编写

Java 单元测试框架，JUnit 和 TestNG。

JUnit5.x 由以下三个只要模块组成。

- JUnit Platform：用于在 JVM 上启动测试框架，统一命令行、Gradle 和 Maven 等方式执行测试入口。
- JUnit Jupiter：包含 JUnit5.x 全新编程模型和扩展机制。
- JUnit Vintage：用于在新的框架中兼容运行 Unit3.x 和 Unit4.x 的测试用例。

JUnit 常用测试注解：

| 注解               | 释义                                                         |
| ------------------ | ------------------------------------------------------------ |
| @Test              | 注明一个方法是测试方法。JUnit 框架会在测试阶段自动找到所有使用该注解表明的测试方法并运行。JUnit5 中取消了该注释的 timeout 参数的支持。 |
| @TestFactory       | 注明一个方法是基于数据驱动的动态测试数据源。                 |
| @ParameterizedTest | 注明一个方法是测试方法，同 @Test。同时可以让一个测试方法使用不同的入参进行多次。 |
| @RepeatedTest      | 让测试方法自定义重复运行次数。                               |
| @BeforeEach        | 与 JUnit4 中的 @Before 类似，可以在每个测试方法运行前，都运行一个指定的方法。在 JUnit5 中，初了运行 @Test 注解的方法，还额外支持运行 @ParameterizedTest 和 @RepeatedTest |
| @AfterEach         | 与 JUnit4 中的 @After类似，可以在每个测试方法运行后，都运行一个指定的方法。在 JUnit5 中，初了运行 @Test 注解的方法，还额外支持运行 @ParameterizedTest 和 @RepeatedTest |
| @BeforeAll         | 与 JUnit4 中的 @BeforeClass 类似，可以在每个测试类运行之前，都运行一个指定的方法。 |
| @AfterAll          | 与 JUnit4 中的 @AfterClass 类似，可以在每个测试类运行之后，都运行一个指定的方法。 |
| @Disabled          | 与 JUnit4 中的 @Ignore 类似，注明一个测试的类或者方法不再运行 |
| @Nested            | 为测试添加嵌套层级，以便组织用例结构                         |
| @Tag               | 为测试类或方法添加标签，以便有选择性的执行                   |

@DisplayName 注解仅仅对于采用 IDE 或者图形化方式展示测试运行结果的场景有效。

当测试用例较多时，为了更好的组织测试结构，推荐所有 JUnit 的 @Nested 注解表达有层次关系的测试用例。

### 8.3.2 命名

单元测试的定义与被测试类一一对应，放置与被测试类相同的包路径下，并以被测试类名称加上 Test 命名。

单元测试代码必须写在工程目录 src/test/java 下，测试资源文件则放在 src/test/resource 下。

主流的 Java 单元测试方法命名规范有两种：一种是传统的以 “test” 开头，然后加待测试场景和期待结果的命名方式；另一种则是以更易于阅读的 “should...When” 结构。

### 8.3.3 断言与假设

断言（assert），封装好了采用判断逻辑，当不满足条件时，该测试用例会被认定为失败；

假设（assume），当条件不满足时，该测试用例会直接退出而不认定为失败，最终记录的状态是跳过。

常用断言相关方法：

| 方法                                    | 释义                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| fail                                    | 断言测试失败                                                 |
| assertTrue/assertFalse                  | 断言条件为真或为假                                           |
| assertNull/assertNotNull                | 断言指定值为 null 或非 null                                  |
| assertEquals/assertNotEquals            | 断言指定两个值等或不等，对于基本数据类型，使用值比较，对于对象使用 equals 方法比较 |
| assertArrayEquals                       | 断言数组元素全部相等                                         |
| assertSame/assertNotSame                | 断言指定两个对象是否为同一个对象                             |
| assertThrows/assertDoesNotThrow         | 断言是否抛出指定类型异常                                     |
| assertTimeout/assertTimeoutPreemptively | 断言是否执行超时，区别在于测试程序是否在同一个线程内执行     |
| assertIterableEquals                    | 断言迭代器中元素全部相等                                     |
| assertLinesMatch                        | 断言字符串与列表元素全部正则匹配                             |
| assertAll                               | 断言多个条件同时满足                                         |

假设方法

| 方法                   | 释义                                                 |
| ---------------------- | ---------------------------------------------------- |
| assumeTrue/assumeFalse | 先判断给定条件为真或为假，再决定是否继续接下来的测试 |

对于断言的选择，优先常用更精确的断言，因为它们通常提供更友好的结果输出格式（包括预期值和实际值）。

对于所有两参数的断言方法，第一个参数是预期结果值，第二个参数才是实际结果值。

AssertJ 的最大特点是流式断言，与 Builder Chain 模式或 Java8 的 stream&filter 写法类似。