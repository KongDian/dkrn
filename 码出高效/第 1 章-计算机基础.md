# 第 1 章 计算机基础

## 1.1 走进 0 与 1 的世界

原码:就是早期用来表示数字的一种方式: 一个正数，转换为二进制位就是这个正数的原码。负数的绝对值转换成二进制位然后在高位补1就是这个负数的原码

反码:正数的反码就是原码，负数的反码等于原码除符号位以外所有的位取反。

补码:正数的补码与原码相同，负数的补码为 其原码除符号位外所有位取反（反码），然后最低位加1。

位移运行

`<<` 左移和 `>>` 运算中符号位均参与移动，除负数右移时，高位补 1 以外，其他情况均在空位补 0。

`>>>` 无符号右移：当向右移时，正负数高位均补 0。

其他位运算：按位取反（~）、按位与（&）、按位或（|）、按位异或（^）。

注意按位与和逻辑与（&&）运算都可以用于条件运算，但后者有短路功能。同样，按位或对应的逻辑或运算（||）也有短路功能。

## 1.2 浮点数

计算机定义了两种小数，分别为定点小数和浮点数。

浮点数是以科学计数法表示。

### 1.2.1 科学计数法

![浮点数表示](图片/浮点数表示.png)

浮点数由符号位、有效数字、指数三部分组成。

### 1.2.2 浮点数表示

当从数学世界的科学记数法映射到计算机内的浮点数，数制从十进制转变为二进制时，相关称谓有所改变：指数称为阶码，有效数字称为位数。

IEEE754标准规定了 4 种浮点数：单精度、双精度、延申单精度，延申双精度。

浮点数无法表示零值，取值区间分为两个区间：正数区间和负数区间。

以32位单精度浮点数为例，最高位为符号位，符号位右侧8位为阶码位。后23位为尾数位。

![单精度浮点数格式](图片/单精度浮点数格式.png)

1. 符号位： 在最高二进制位上分配1位表示浮点数的符号，0表示正数，1表示负数。

2. 阶码位： 在符号位右侧分配8位用来存储指数，作为阶码位。而阶码位存储的是指数对应的移码，而不是指数对应的原码或者补码。

   移码：（又叫增码）是符号位取反的补码

   移码的计算规则：[X移]=x+ 2^(n-1) n为x的二进制位数，含符号位
   移码的几何意义是把真值映射到一个正数域，可以直观的反应两个真值的大小。
   而在计算机中，假设指数的真值为e，阶码为E，则有E = e + 2^(n-1) - 1;
   偏移值为 2^(n-1) - 1;而不是2^(n-1)的原因：
   8个二进制位的取值范围为[-128-127]，现在将指数变成移码的形式，即将区间[-128-127]正向平移到正数域，区间内每个数加上128，变为[0, 255],计算机中规定阶码全为0或者全为1的两种情况当作特殊值处理(0，无穷大)去掉这两个值，则范围变为[1,254]，按照换算关系，这样得到的指数范围为[-127, 126]，指数最大只能取到126，这样就缩小了浮点数的取值范围，所以将阶码的偏移量设为2^(n-1) - 1;这样表示的范围为[-126, 127]

3. 尾数位

   最右侧分配连续 23 位用来存储有效数字，IEEE754 标准规定尾数位以原码表示。科学计数法进行规格化的目的是保证浮点数表示的唯一性。二进制数字规格化后的尾数形式为 `1.xyz`，满足 1<= |a|< 2。为了节省空间，将符合规格化尾数的首个 1 省略，所以尾数表面是 23 位，实际表示了 24 位二进制数。

常用浮点数规格化表示结果：

![浮点数规格化表示](图片/浮点数规格化表示.png)

### 1.2.3 加减运算

浮点数之间的加减法运算：
（1）零值检测：如果存在一个数为0（阶码与尾数全为0），直接得出结果。

（2）对阶操作：通过比较阶码的大小来判断小数点的位置是否对齐，阶码不相等，表示并未对齐，若未对齐，则需要通过移动尾数改变阶码的大小。尾数向右移则阶码加 1，尾数向左移动 1 位，阶码减 1。因为向左移动会使误差变大，所以一般为选择较小的阶码对其尾数进行右移操作。（在进行负数移动时，首先求取后23号的补码，之后进行相应的移动，最后在最高位添加1，也就是默认的最高阶位1）；

（3）尾数求和：在对阶操作结束之后，直接按位相加即可（如果是负数，需要转换为补码再进行计算）。

（4）结果规格化：如果运算结果不满足规格化要求，则需要通过尾数的左移或右移达到规格化形式，左移称为左归，右移称为右归。

（5）结果舍入：在对阶过程或右规时，尾数需要右移，最右端被移出的位会被丢弃，从而导致结果精度的损失。为了减少这种精度的损失，先将移出的这部分数据保存起来，称为保护位，等到规格化后再根据保护位进行舍入处理。

### 1.2.4 浮点数使用

在要求绝对精确表示的业务场景下，比如金融行业的货币表示，推荐使用整型存储其最小单位的值，展示时可以转换成该货币的常用单位，比如人民币使用分存储，美元使用美分存储。在要求精确表示小数点n 位的业务场景下，比如圆周率要求存储小数点后1000 位数字，使用单精度和双精度浮点数类型保存是难以做到的，这时推荐采用数组保存小数部分的数据。在比较浮点数时，由于存在误差，往往会出现意料之外的结果，所以禁止通过判断两个浮点数是否相等来控制某些业务流程。在数据库中保存小数时，推荐使用decimal 类型，禁止使用float 类型和double 类型。因为这两种类型在存储的时候，存在精度损失的问题。

## 1.3 字符集与乱码

在ASCII 码中，有两个特殊的控制字符10 和13 ，前者是 LF  即 “\n”，后者是 CR 即 “\r”，在编码过程中，代码的换行虽然是默认不可见的，但在不同的操作系统中，表示方式是不样的。在 UNIX 系统中，换行使用换行符 "\\n"，在window系统中，换行使用 "\\r\\n"；在旧版 macOS 中，换行符使用回车符 "\\r"，在新版macOS 中使用与 UNIX 系统相同的换行方式。前编码环境使用换行方式是LF，这也是推荐的换行方式，避免出现源码在不同操作系统中换行显示不同的情况。

数据库是存储字符之源，在不同层次上都能设置独立的字符集。最好所有情况下字符集设置都是一致的。

## 1.4 CPU 与内存

CPU 是计算机的核心部件。其内部结构如图所示：

![CPU 的内部结构](图片/CPU 的内部结构.png)

内存物理结构由内存芯片、电路板、控制芯片、相关支持模块等组成，内存芯片结构比较简单，核心是存储单元，支持模块是地址译码器和读写控制器，如图所示。

![计算机存储方式](图片/计算机存储方式.png)

Java 的内存交给 JVM 进行自动分配和释放，这个过程称为垃圾回收机制。

## 1.5 TCP/IP

### 1.5.1 网络协议

TCP/IP中文译为传输控制协议/因特网互联协议，在这个家族中还有其他协议，HTTP、HTTPS、FTP、SMTP、UDP、ARP、PPP、IEEE 802.x 等协议。

从严格意义上来讲它是一个协议族，因为 TCP、IP 是其中最为核心的协议，所以将该协议族称为 TCP/IP。另一个比较耳熟能详的便是ISO/OSI的七层传输协议。

![TCP-IP协议分层框架](图片/TCP-IP协议分层框架.jpg)

- 链路层：以字节为单位把0与1进行分组，定义数据帧，写入源和目标机器的物理地址、数据、校验位来传输数据。

  ![链路层报文结构](图片/链路层报文结构.png)

- 网际层：根据IP定义网络地址，区分网段。子网内根据地址解析协议（ARP）进行MAC寻址，子网外进行路由转发数据包，这个数据包即IP数据包。

- 传输层：数据包通过网络层发送到目标计算机之后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通信。最典型的传输层协议是TCP和UDP，其中UDP是面向连接的，而UDP则是无面向连接的。

- 应用层：传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据。

总结一下，程序在发送消息时，应用层按既定的协议打包数据，随后由传输层加上双方的端口号，由网络层加上双方的IP地址，由链路层加上双方的MAC地址，并将数据拆分成数据帧，经过多个路由器和网关后，到达目标机器。 简而言之，就是按 “端口+IP地址+MAC地址"这样的路径进行数据的封装和发送，解包的时候反过来操作即可。

### 1.5.2 IP 协议

